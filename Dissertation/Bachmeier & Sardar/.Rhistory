library(tstools)
library(lmtest)
project.raw <- read.csv("Final Data.csv", header=TRUE)
dataset <- ts(project.raw, start=c(1970,1), frequency=12)
oil <- dataset[,"oil"]
recession <- ts(!as.logical(dataset[,"recession"]), start=start(dataset), frequency=frequency(dataset))
calc.nopi <- function(oil, k) {
calc.aux <- function(data, nopi=NULL) {
if (length(data) < k+1) {
return(ts(nopi, start=time(oil)[k+1],
frequency=frequency(oil)))
} else {
pctChange <- log(data[k+1]) - log(max(data[1:k]))
return(calc.aux(data[-1], c(nopi, max(pctChange, 0))))
}
}
return(calc.aux(oil))
}
nopi <- calc.nopi(oil, 36)
inter <- nopi*recession
recession
subset_1 <- subset(dataset, select = c("oil", "recession", "dip_motor"))
subset_1 <- ts(subset_1, start = c(1970,1), frequency=12)
lag_choice <- function(h, lhs) { return(1) }
rfest <- function(h, lhs) {
k <- lag_choice(h, lhs)
ds <- ts.combine(subset_1[, lhs], nopi, inter)
rhs <- lags(ds, h:(h+k-1), type="bylag")
b <- coefficients(tsreg(subset_1[, lhs], rhs))
names(b) <- c("Intercept", lhs, "nopi", "interaction")
return(list(name=lhs, h=h, coef=b, recession=b[3]+b[4], expansion=b[3], diff=-b[4]))
}
combinations <- expand.grid(colnames(subset_1)[-(1:2)], 1:24)
com <- lapply(1:nrow(combinations), function(ii) { list(varname=as.character(combinations[ii,1]), h=as.integer(combinations[ii,2])) })
rfvar <- lapply(com, function(z) { rfest(z$h, z$varname) })
subset_1 <- subset(dataset, select = c("oil", "recession", "dip_motor"))
subset_1 <- ts(subset_1, start = c(1970,1), frequency=12)
lag_choice <- function(h, lhs) { return(1) }
rfest <- function(h, lhs) {
k <- lag_choice(h, lhs)
ds <- ts.combine(subset_1[, lhs], nopi, inter)
rhs <- lags(ds, h:(h+k-1), type="bylag")
b <- coefficients(tsreg(subset_1[, lhs], rhs))
names(b) <- c("Intercept", lhs, "nopi", "interaction")
return(list(name=lhs, h=h, coef=b, recession=b[3]+b[4], expansion=b[3], diff=-b[4]))
}
combinations <- expand.grid(colnames(subset_1)[-(1:2)], 1:24)
com <- lapply(1:nrow(combinations), function(ii) { list(varname=as.character(combinations[ii,1]), h=as.integer(combinations[ii,2])) })
rfvar <- lapply(com, function(z) { rfest(z$h, z$varname) })
results <- matrix(NA, nrow=24, ncol=length(colnames(subset_1)[-(1:2)]))
colnames(results) <- colnames(subset_1)[-(1:2)]
results[] <- 1.5
for (result in rfvar) { results[result$h, result$name] <- result$diff }
print(results)
rfvar
nopi
library(tstools)
library(lmtest)
project.raw <- read.csv("Final Data.csv", header=TRUE)
dataset <- ts(project.raw, start=c(1970,1), frequency=12)
oil <- dataset[,"oil"]
r <- dataset[,"ffr"]
recession <- ts(!as.logical(dataset[,"recession"]), start=start(dataset), frequency=frequency(dataset))
calc.nopi <- function(oil, k) {
calc.aux <- function(data, nopi=NULL) {
if (length(data) < k+1) {
return(ts(nopi, start=time(oil)[k+1],
frequency=frequency(oil)))
} else {
pctChange <- log(data[k+1]) - log(max(data[1:k]))
return(calc.aux(data[-1], c(nopi, max(pctChange, 0))))
}
}
return(calc.aux(oil))
}
nopi <- calc.nopi(oil, 36)
inter <- nopi*recession
het.test <- function(varname) {
cat("Doing the test for: ", varname, "\n")
# Compute the AIC and SIC for lags 1-24
output <- lapply(1:24, function(k) {
rhs <- ts.intersect(lags(dataset[, varname], 1:k), lags(nopi, 1:k), lags(inter, 1:k), lags(r, 1:k))
fit <- tsreg(dataset[, varname], rhs)
return(list(fit=fit, lags=k, aic=AIC(fit), sic=BIC(fit)))
})
# Returns the lag length with the lowest criteria value
lowest.crit <- function(fits, min.crit=Inf, min.lags=0, crit="sic") {
if (length(fits) < 1) {
return(min.lags)
} else {
current.crit <- if (fits[[1]][[crit]] < min.crit) { fits[[1]][[crit]] } else { min.crit }
current.lags <- if (fits[[1]][[crit]] < min.crit) { fits[[1]]$lags } else { min.lags }
return(lowest.crit(fits[-1], current.crit, current.lags))
}
}
k <- lowest.crit(output)
# Unrestricted model
rhs.u <- ts.intersect(lags(dataset[, varname], 1:k), lags(nopi, 1:k), lags(inter, 1:k), lags(r, 1:k))
fit.u <- tsreg(dataset[, varname], rhs.u)
# White Test
u2 <- fit.u$residuals^2
y <- fitted(fit.u)
#Obtain R2
Ru2<- summary(lm(u2 ~ y + I(y^2)))$r.squared
#Calculate LM test statistic=n*R2
LM <- 537*Ru2
#Obtain p-value
p.value <- 1-pchisq(LM, k)  #k degrees of freedom
return(p.value)
}
dip.names <- colnames(dataset)[8:25]
het_test.results <- lapply(dip.names, het.test)
names(het_test.results) <- dip.names
lapply(het_test.results, function(z) {z[1]})
gctest <- function(varname) {
cat("Doing the test for: ", varname, "\n")
# Compute the AIC and SIC for lags 1-24
output <- lapply(1:24, function(k) {
rhs <- ts.intersect(lags(dataset[, varname], 1:k), lags(nopi, 1:k), lags(inter, 1:k), lags(r, 1:k))
fit <- tsreg(dataset[, varname], rhs)
return(list(fit=fit, lags=k, aic=AIC(fit), sic=BIC(fit)))
})
# Returns the lag length with the lowest criteria value
lowest.crit <- function(fits, min.crit=Inf, min.lags=0, crit="sic") {
if (length(fits) < 1) {
return(min.lags)
} else {
current.crit <- if (fits[[1]][[crit]] < min.crit) { fits[[1]][[crit]] } else { min.crit }
current.lags <- if (fits[[1]][[crit]] < min.crit) { fits[[1]]$lags } else { min.lags }
return(lowest.crit(fits[-1], current.crit, current.lags))
}
}
k <- lowest.crit(output)
# Do the restricted and unrestricted regressions
rhs.u <- ts.intersect(lags(dataset[, varname], 1:k), lags(nopi, 1:k), lags(inter, 1:k), lags(r, 1:k))
rhs.r <- ts.intersect(lags(dataset[, varname], 1:k), lags(nopi, 1:k), lags(r, 1:k))
fit.u <- tsreg(dataset[, varname], rhs.u)
fit.r <- tsreg(dataset[, varname], rhs.r)
#return(waldtest(fit.u, fit.r, vcov=sandwich::NeweyWest))
return(waldtest(fit.u, fit.r, vcov=sandwich::NeweyWest))
}
dip.names <- colnames(dataset)[8:25]
gctest.results <- lapply(dip.names, gctest)
names(gctest.results) <- dip.names
lapply(gctest.results, function(z) { z[2,4] })
gctest <- function(varname) {
cat("Doing the test for: ", varname, "\n")
# Compute the AIC and SIC for lags 1-24
output <- lapply(1:24, function(k) {
rhs <- ts.intersect(lags(dataset[, varname], 1:k), lags(nopi, 1:k), lags(inter, 1:k), lags(r, 1:k))
fit <- tsreg(dataset[, varname], rhs)
return(list(fit=fit, lags=k, aic=AIC(fit), sic=BIC(fit)))
})
# Returns the lag length with the lowest criteria value
lowest.crit <- function(fits, min.crit=Inf, min.lags=0, crit="aic") {
if (length(fits) < 1) {
return(min.lags)
} else {
current.crit <- if (fits[[1]][[crit]] < min.crit) { fits[[1]][[crit]] } else { min.crit }
current.lags <- if (fits[[1]][[crit]] < min.crit) { fits[[1]]$lags } else { min.lags }
return(lowest.crit(fits[-1], current.crit, current.lags))
}
}
k <- lowest.crit(output)
# Do the restricted and unrestricted regressions
rhs.u <- ts.intersect(lags(dataset[, varname], 1:k), lags(nopi, 1:k), lags(inter, 1:k), lags(r, 1:k))
rhs.r <- ts.intersect(lags(dataset[, varname], 1:k), lags(nopi, 1:k), lags(r, 1:k))
fit.u <- tsreg(dataset[, varname], rhs.u)
fit.r <- tsreg(dataset[, varname], rhs.r)
#return(waldtest(fit.u, fit.r, vcov=sandwich::NeweyWest))
return(waldtest(fit.u, fit.r))
}
dip.names <- colnames(dataset)[8:25]
gctest.results <- lapply(dip.names, gctest)
names(gctest.results) <- dip.names
lapply(gctest.results, function(z) { z[2,4] })
setwd("C:/Users/Naafey Sardar/oil")
library(tstools)
library(lmtest)
project.raw <- read.csv("Monthly Data.csv", header=TRUE)
dataset <- ts(project.raw, start=c(1972,1), frequency=12)
oil <- dataset[,"oil"]
recession <- ts(!as.logical(dataset[,"recession"]), start=start(dataset), frequency=frequency(dataset))
calc.nopi <- function(oil, k) {
calc.aux <- function(data, nopi=NULL) {
if (length(data) < k+1) {
return(ts(nopi, start=time(oil)[k+1],
frequency=frequency(oil)))
} else {
pctChange <- log(data[k+1]) - log(max(data[1:k]))
return(calc.aux(data[-1], c(nopi, max(pctChange, 0))))
}
}
return(calc.aux(oil))
}
nopi <- calc.nopi(oil, 36)
inter <- nopi*recession
library(tstools)
library(lmtest)
project.raw <- read.csv("Monthly Data.csv", header=TRUE)
dataset <- ts(project.raw, start=c(1972,1), frequency=12)
oil <- dataset[,"oil"]
recession <- ts(!as.logical(dataset[,"recession"]), start=start(dataset), frequency=frequency(dataset))
calc.nopi <- function(oil, k) {
calc.aux <- function(data, nopi=NULL) {
if (length(data) < k+1) {
return(ts(nopi, start=time(oil)[k+1],
frequency=frequency(oil)))
} else {
pctChange <- log(data[k+1]) - log(max(data[1:k]))
return(calc.aux(data[-1], c(nopi, max(pctChange, 0))))
}
}
return(calc.aux(oil))
}
nopi <- calc.nopi(oil, 36)
inter <- nopi*recession
het.test <- function(varname) {
cat("Doing the test for: ", varname, "\n")
# Compute the AIC and SIC for lags 1-24
output <- lapply(1:24, function(k) {
rhs <- ts.intersect(lags(dataset[, varname], 1:k), lags(nopi, 1:k), lags(inter, 1:k))
fit <- tsreg(dataset[, varname], rhs)
return(list(fit=fit, lags=k, aic=AIC(fit), sic=BIC(fit)))
})
# Returns the lag length with the lowest criteria value
lowest.crit <- function(fits, min.crit=Inf, min.lags=0, crit="sic") {
if (length(fits) < 1) {
return(min.lags)
} else {
current.crit <- if (fits[[1]][[crit]] < min.crit) { fits[[1]][[crit]] } else { min.crit }
current.lags <- if (fits[[1]][[crit]] < min.crit) { fits[[1]]$lags } else { min.lags }
return(lowest.crit(fits[-1], current.crit, current.lags))
}
}
k <- lowest.crit(output)
# Unrestricted model
rhs.u <- ts.intersect(lags(dataset[, varname], 1:k), lags(nopi, 1:k), lags(inter, 1:k))
fit.u <- tsreg(dataset[, varname], rhs.u)
# White Test
u2 <- fit.u$residuals^2
y <- fitted(fit.u)
#Obtain R2
Ru2<- summary(lm(u2 ~ y + I(y^2)))$r.squared
#Calculate LM test statistic=n*R2
LM <- 516*Ru2
#Obtain p-value
p.value <- 1-pchisq(LM, k)  #k degrees of freedom
return(p.value)
}
dip.names <- colnames(dataset)[3:14]
het_test.results <- lapply(dip.names, het.test)
het.test <- function(varname) {
cat("Doing the test for: ", varname, "\n")
# Compute the AIC and SIC for lags 1-24
output <- lapply(1:24, function(k) {
rhs <- ts.intersect(lags(dataset[, varname], 1:k), lags(nopi, 1:k), lags(inter, 1:k))
fit <- tsreg(dataset[, varname], rhs)
return(list(fit=fit, lags=k, aic=AIC(fit), sic=BIC(fit)))
})
# Returns the lag length with the lowest criteria value
lowest.crit <- function(fits, min.crit=Inf, min.lags=0, crit="sic") {
if (length(fits) < 1) {
return(min.lags)
} else {
current.crit <- if (fits[[1]][[crit]] < min.crit) { fits[[1]][[crit]] } else { min.crit }
current.lags <- if (fits[[1]][[crit]] < min.crit) { fits[[1]]$lags } else { min.lags }
return(lowest.crit(fits[-1], current.crit, current.lags))
}
}
k <- lowest.crit(output)
# Unrestricted model
rhs.u <- ts.intersect(lags(dataset[, varname], 1:k), lags(nopi, 1:k), lags(inter, 1:k))
fit.u <- tsreg(dataset[, varname], rhs.u)
# White Test
u2 <- fit.u$residuals^2
y <- fitted(fit.u)
#Obtain R2
Ru2<- summary(lm(u2 ~ y + I(y^2)))$r.squared
#Calculate LM test statistic=n*R2
LM <- 516*Ru2
#Obtain p-value
p.value <- 1-pchisq(LM, k)  #k degrees of freedom
return(p.value)
}
dip.names <- colnames(dataset)[3:13]
het_test.results <- lapply(dip.names, het.test)
names(het_test.results) <- dip.names
lapply(het_test.results, function(z) {z[1]})
subset_1 <- subset(dataset, select = c(oil, recession, rpce, durable, nondurable, motor, furnishings, recreational, food, clothing, gasoline, saving))
subset_1 <- ts(subset_1, start = c(1972,1), frequency=12)
gctest <- function(varname) {
cat("Doing the test for: ", varname, "\n")
# Compute the AIC and SIC for lags 1-24
output <- lapply(1:24, function(k) {
rhs <- ts.intersect(lags(subset_1[, varname], 1:k), lags(nopi, 1:k), lags(inter, 1:k))
fit <- tsreg(subset_1[, varname], rhs)
return(list(fit=fit, lags=k, aic=AIC(fit), sic=BIC(fit)))
})
# ksic is the lag length with the lowest SIC
lowest.sic <- function(fits, min.sic=Inf, min.lags=0) {
if (length(fits) < 1) {
return(min.lags)
} else {
current.sic <- if (fits[[1]]$sic < min.sic) { fits[[1]]$sic } else { min.sic }
current.lags <- if (fits[[1]]$sic < min.sic) { fits[[1]]$lags } else { min.lags }
return(lowest.sic(fits[-1], current.sic, current.lags))
}
}
ksic <- lowest.sic(output)
# Do the restricted and unrestricted regressions
rhs.u <- ts.intersect(lags(subset_1[, varname], 1:ksic), lags(nopi, 1:ksic), lags(inter, 1:ksic))
rhs.r <- ts.intersect(lags(subset_1[, varname], 1:ksic), lags(nopi, 1:ksic))
fit.u <- tsreg(subset_1[, varname], rhs.u)
fit.r <- tsreg(subset_1[, varname], rhs.r)
#return(waldtest(fit.u, fit.r, vcov=sandwich::NeweyWest))
return(waldtest(fit.u, fit.r, vcov = sandwich::NeweyWest))
}
dip.names <- colnames(subset_1)[3:12]
gctest.results <- lapply(dip.names, gctest)
names(gctest.results) <- dip.names
gctest.results
subset_2 <- subset(dataset, select = c(oil, recession, u))
subset_2 <- ts(subset_2, start = c(1972,1), frequency=12)
gctest <- function(varname) {
cat("Doing the test for: ", varname, "\n")
# Compute the AIC and SIC for lags 1-24
output <- lapply(1:24, function(k) {
rhs <- ts.intersect(lags(subset_2[, varname], 1:k), lags(nopi, 1:k), lags(inter, 1:k))
fit <- tsreg(subset_2[, varname], rhs)
return(list(fit=fit, lags=k, aic=AIC(fit), sic=BIC(fit)))
})
# ksic is the lag length with the lowest SIC
lowest.sic <- function(fits, min.sic=Inf, min.lags=0) {
if (length(fits) < 1) {
return(min.lags)
} else {
current.sic <- if (fits[[1]]$sic < min.sic) { fits[[1]]$sic } else { min.sic }
current.lags <- if (fits[[1]]$sic < min.sic) { fits[[1]]$lags } else { min.lags }
return(lowest.sic(fits[-1], current.sic, current.lags))
}
}
ksic <- lowest.sic(output)
# Do the restricted and unrestricted regressions
rhs.u <- ts.intersect(lags(subset_2[, varname], 1:ksic), lags(nopi, 1:ksic), lags(inter, 1:ksic))
rhs.r <- ts.intersect(lags(subset_2[, varname], 1:ksic), lags(nopi, 1:ksic))
fit.u <- tsreg(subset_2[, varname], rhs.u)
fit.r <- tsreg(subset_2[, varname], rhs.r)
#return(waldtest(fit.u, fit.r, vcov=sandwich::NeweyWest))
return(waldtest(fit.u, fit.r))
}
dip.names <- colnames(subset_2)[3]
gctest.results <- lapply(dip.names, gctest)
names(gctest.results) <- dip.names
gctest.results
